
## 基础的 lua 接口

```lua
local sproto = require "sproto"
local sprotocore = require "sproto.core" -- optional
```

- `sproto.new(spbin)` creates a sproto object by a schema binary string (generates by parser).  根据二进制文件创建 一个 sproto object
- `sprotocore.newproto(spbin)` creates a sproto c object by a schema binary string (generates by parser).  根据二进制文件创建 一个 sproto C object
- `sproto.sharenew(spbin)` share a sproto object from a sproto c object (generates by sprotocore.newproto). 从一个 Sproto C 对象分享一个 sproto 对象
- `sproto.parse(schema)` creates a sproto object by a schema text string (by calling parser.parse)  根据 string 生成 sproto 对象
- `sproto:exist_type(typename)` detect whether a type exist in sproto object.  在sproto 对象中是否存在一个类型
- `sproto:encode(typename, luatable)` encodes a lua table with typename into a binary string.  根据 lua table 生成一个 typename
- `sproto:decode(typename, blob [,sz])` decodes a binary string generated by sproto.encode with typename. If blob is a lightuserdata (C ptr), sz (integer) is needed.
- `sproto:pencode(typename, luatable)` The same with sproto:encode, but pack (compress) the results. 功能和 encode 相同但是会压缩
- `sproto:pdecode(typename, blob [,sz])` The same with sproto.decode, but unpack the blob (generated by sproto:pencode) first.
- `sproto:default(typename, type)` Create a table with default values of typename. Type can be nil , "REQUEST", or "RESPONSE". 

## sproto C sharp

https://github.com/lvzixun/sproto-Csharp

## UniProtoMessagePackage

`UniProtoMessagePackage`

Request 和 Respone 的包装类。

有 ResultCode , bool Responed, bool Processed 这些东西， 用于处理， Session 用于确定用户， callback 回调函数

Process 调用 callback，进行信息处理

```c#
public void RegisterLongPull<TReq,TRep>(int msgId,System.Action<TRep> callback)where TReq : SprotoTypeBase, new() where TRep : SprotoTypeBase, new()
{
	TReq request = new();
	UniProtoMessagePackage<TRep> package = new UniProtoMessagePackage<TRep>(msgId, request);
	package.Callback= (rep) =>
	{
		callback(package.GetResponse());
		UniTask.NextFrame().GetAwaiter().OnCompleted(() =>
		{
			RegisterLongPull<TReq, TRep>(msgId,callback);
		});
		
	};
	network.WriteProtoPackage(package);
	
}
```

持久化 callback 函数 

综上所述，`UniTask.NextFrame().GetAwaiter().OnCompleted`的作用是在下一帧的开始时再次注册长轮询请求。这样做的目的可能是为了持续地、周期性地发送请求，比如在网络游戏中定期从服务器获取数据更新。通过这种方式，可以确保每帧都有机会发送请求，同时不会阻塞当前帧的执行，从而保持游戏的流畅性。

