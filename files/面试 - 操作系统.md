---
tags:
  - 面试
---
## 协程 

- 线程和进程都是同步机制， 协程是异步机制
- 线程是抢占式的，协程是非抢占式的。 同一时间只有一个协程工作，使用权限由用户管理
- 线程可以有多个协程
- 协程保留上一次调用的状态

## 进程和线程的切换流程

**进程的切换**
1. 切换页表使用新的地址空间， 线程共享进程的虚拟地址。
2. 切换内核栈和硬件上下文

对于线程 不需要第一步。

## 虚拟地址切换比较耗时

进程有自己的虚拟地址，虚拟的地址转换为物理地址需要查找页表，**这是比较耗时的**。因此使用TLB进行页表的查找(缓存)。

**由于切换进程**，页表也需要进行切换，**此时TLB失效** 缓存的命中率低。此时虚拟内存转换到物理的地址的速度就比较慢。

而线程切换不会导致TLB失效。因此速度较快。

## 进程的通信方式

- 管道： **问题** ：A：半双工-> 单向流动，B ：只有在情缘关系的进程之间才可以通信
- 信号
- 信号量 : 一个计数器。
- 消息队列 ： 容量受到系统限制，需要注意读的时候需要考虑上一次有没有读完数据。
- 共享内存 ： 需要保持同步，注意安全
- socket

## 进程同步方式

1. 临界区 ： 通过多线程串行访问公共资源或者代码。速度快
	- 优点 ： 同一时间只有一个线程能访问数据
	- 缺点 ： 只能同步本进程内的数据， 对于其他线程无法控制
2. 互斥量：只有拥有互斥对象的线程才具有访问资源的权限
	1. 优点 ： 可以作用不同引用程序之间实现对于资源拿到安全
	2. 缺点 ： 资源占用大，不能分布式
3. 信号量 ： 允许多个线程在同一时刻访问同意资源，数量=1就是互斥量
	1. 优点 ： 可以对 socket 程序中的线程同步
	2. 缺点 ： 不能分布式， 对于读写的维护比较困难。 PV操作不易控制
4. 事件 ： 通知线程一些时间已经发成，从而启动后继任务
	1. 优点：可以实现不同进程中的线程同步

## 线程同步方式

1. 临界区  保护资源/代码，同一时间只能被一个线程访问。其他的挂起  -- 只能在一个进程中
2. 事件
3. 互斥量
4. 信号量

## 线程分类

用户级线程，内核级线程。

## 临界区

一次仅有一个线程使用的资源被称为临界资源。

- 如果资源有线程，则其他线程想要访问必须等待
- 进入临界区的线程 ， **在有限时间内推出**
- 如果进程不能进入自己的临界区，**应让出CPU** 避免出现忙等。

## 死锁

- 互斥
- 请求与保持
- 不剥夺
- 循环的等待

**处理死锁**

- 破除请求与保持 ： 一次性获得所有资源
- 破除不可剥夺 ： 允许强行占有
- 破除循环等待 ： 编号，按照顺序获取资源。 一个进行只有获取小编号后才能申请较大编号的进程

## 进程调度

- 先来先服务 ： 不利于长作业，利于短作业。
- 短作业优先 ： 长作业可能饿死
- 最短剩余时间优先 ： 抢占式 ， 按剩余时间进行调度，如果当前进程需要的时间少，则挂起当前的进程
- 时间片轮转 ： FCFS 进程可以执行一个时间片，用完则送到队列末尾
- 优先级调度

## 进程状态

创建，就绪，执行，阻塞，

![yvgRsIWXSTpHlft.png](https://s2.loli.net/2024/08/14/yvgRsIWXSTpHlft.png)
阻塞 ： 往往需要等待外设，人工干预的， 到就绪 ： 条件完成
到就绪态： 非人工干预

## 分段 分页

- 页表 一维， 段表 二维
- 页大小u可变，端可变
- 分页 -> 虚拟内存  分段 -> 使得程序/数据进行逻辑划分，方便保护

## 交换空间

内存满了 会把页转移到硬盘空间，这就是交换空间。 物理内存+ 交换空间 就是虚拟内存可用容量。

## 物理地址，逻辑地址，有效地址， 线性地址，虚拟地址

物理地址 ： 真实内存地址

线性地址、虚拟地址：CPU在保护模式下，“**段基址+段内偏移地址”叫做线性地址**，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。

逻辑地址、有效地址：无论CPU在什么模式下，段内偏移地址又称为有效地址或者逻辑地址（只是叫法不一样罢了），例如实模式下 `“mov ax, [0x7c00]”`，0x7c00就是逻辑地址（或有效地址），但这条指令最终操作的物理地址是`DS*16+0x7c00`


![500](https://img2018.cnblogs.com/i-beta/1273933/202003/1273933-20200301192139794-1810567553.png)


## 页替换算法

NRU 最近未使用

FIFO ： 先进先出
第二次机会 ： FIFO 的升级， 在删除页面之前，检查页面是否仍在使用
时钟算法 ： 
LRU 算法 ： 最近最少
NFU ： 最近不经常使用
老化算法 ： 近似LRU
工作集算法

## 虚拟内存

让物理内存扩大为更大的逻辑内存，从而热昂程序获得更多的可用内存。虚拟内存使用部分加载技术，让进程/资源的部分页面加载到内存，这样看起来就好像内存变大了。

**实现：** 分页，分段，段页

## IO多路复用

- 用户处理多个描述字
- TCP服务器既要处理监听接口，又要出现已连接套接口
- 既要TCP，UDP
- 处理多个服务器协议
- 相较于多线程/进程 ，IO多路复用的优势：系统开销小，不必创建进程/线程，不必维护进程和线程

## 硬链接，软链接

**由于linux下的文件是通过索引节点（Inode）来识别文件**，**硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配inode。每添加一个一个硬链接，文件的链接数就加1。**

**硬连接之间没有主次之分，删除某个硬链接，只是将其从目录的数据块中删除相关信息，并且文件链接数减一**。不会从inode表中删除inode,除非只剩下一个链接数。

> 如果我们这时候再删除aa.link这个文件，系统只会删除掉inode table中aa.link指向的inode信息，和hardlink 目录项中aa.link的相关信息。然后会将aa.link inode指针所指向的数据块设置为空闲的状态，告诉系统这些数据块可以被再次使用。而里面的内容却不会被删除，直到新的数据覆盖为止！

***********************
（又称符号链接，即 soft link 或 symbolic link）：**相当于我们 Windows 中的快捷方式，即如果你软链接一个目录，只是一个目录的快捷方式到指定位置，操作系统找这个快捷方式会直接找到真实目录下的文件。**  innode 不同

再次查看，原文件大小发生了改变，而链接文件大小依旧没变化。

这其实就是软链接的特性之一，**因为软链接的inode指向的数据块保存的是 原文件的路径，如果没有路径，是由文件名，默认会在软链接所在路径查找**

就是一个重定向

## 中断

1. 保护现场
2. 开中断
3. 终端处理
4. 关中断
5. 恢复现场

## select poll epoll

select，poll，epoll 都是 IO 多路复用的机制。何为 IO 多路复用的机制？IO 多路复用的本质是通过一种机制，让单个进程可以监视多个描述符，当发现某个描述符就绪之后，能够通知程序进行相应的读写操作


**select ： 时间 O(n)**  仅仅知道IO时间，不知道是哪个流，无差别轮询。



**poll ： 时间 O(n)**  
讲解了 select 函数之后，相信各位读者对 poll 的理解便没有多大难度了。poll 的机制与 select 几乎相同，会对管理的描述符进行轮询操作，并根据描述符的状态进行相应的处理。

poll 将用户传入的数组拷贝到内核空间，然后查询每个描述符对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有描述符后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时。

**epoll :  时间 O(1)**
会基于时间进行通知 每个事件关联到 fd 上

epoll 是基于事件驱动的 IO 方式，与 select 相比，epoll 并没有描述符个数限制。

epoll 使用一个文件描述符管理多个描述符，它将文件描述符的事件放入内核的一个事件表中，从而在用户空间和内核空间的复制操作只用实行一次即可。


## 虚拟内存专题

让程序认为正在使用一个连续可用的内存。

直接使用内存的问题：
1. 内存空间利用率低
2. 读写内存不安全
3. 内存间存在安全性问题
4. 内存读写效率问题：如果多个进行同时运行，分配的内存总和可能大于实际可用内存，需要将其他程序放入硬盘，并将新程序存入内存。频繁如此，效率低。

### 1. 虚拟内存

地址空间不存在，只是程序认为拥有 4G 内存。实际用来多少空间，操作系统就在磁盘上划分多少。真正运行时，需要某些数据不在物理内存的时候，会触发缺页异常，这时候才会进行数据拷贝。


系统将虚拟内存分割为 $P= 2^p$ 大小的虚拟页， 物理内存同理被分为物理页

**虚拟页分为互不相交的三种**

1. 未分配的： 系统还未分配的页。 **没有任何数据和它们像管理，不占任何磁盘空间**
2. 未缓存的： 内有缓存在物理存储器的已分配页
3. 缓存的： 当前缓存在物理存储器中的已分配页

![lMCRdBEcx8IjGKT.png](https://s2.loli.net/2024/08/18/lMCRdBEcx8IjGKT.png)


### 2. 页表

页表分为两部分：

第一部分：记录页是否在内存上
第二部分：记录如果在物理内存上的话，记录物理内存地址。

如果数据不在物理内存，则发生缺页异常。

![MDBmc6sSHORF4L8.png](https://s2.loli.net/2024/08/18/MDBmc6sSHORF4L8.png)
8个 PTE ：

四个虚拟页 在物理内存中
两个未分配
剩下的，分配了但是不在物理内存中

当访问有效位未1的时候，可以通过页表查找到物理地址
访问有效位未0的时候，会出现缺页中断。将一个物理页替换未待使用的页(从磁盘内)，