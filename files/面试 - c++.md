---
tags:
  - 面试
---
## malloc 底层原理

程序使用 虚拟内存概念  通过驻留集 获得真实的物理地址。

malloc  根据虚拟内存的需求申请物理内存。

https://blog.csdn.net/caiziming_001/article/details/139213036

brk()的实现方式就是将「堆顶」指针向高地址移动，获得新的内存空间。并且malloc()源码中默认定义了阈值，如果用户分配内存小于128KB则通过brk()申请内存。

### :RiStarSmileFill: malloc()分配的是物理内存 吗？

这个答案很明显，malloc分配的是虚拟内存，但是下一句话更加重要！

如果**分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的**，这样就不会占用物理内存了。

1. 在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中；
2. 就会**触发缺页中断**，
3. 然后操作系统会**建立虚拟内存和物理内存之间的映射关系**。

### ⭐️malloc()竟然会构建内存池！

malloc() 在分配内存的时候，会预分配更大的空间作为内存池。

也就是说，当我们调用brk()系统调用申请堆内存，仍然会为我们分配超过128KB字节的内存。即使你 malloc()的内存远小于128k也是一样。

为什么malloc要使用内存池来进行管理呢？

### free释放内存，会马上归还给操作系统吗？


通过 free 释放内存后，堆内存还是存在的，并没有归还给操作系统。当然，当进程退出后，操作系统就会回收进程的所有资源。

**但是！**

**如果我们使用mmap方式申请内存，free释放内存后就会马上归还操作系统。**

- malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；
- malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。

## new 的多种方法

- operater new ： 先分配空间，然后调用构造函数(通过 placement new 来完成)
- plcaement new：  在已经分配成功的空间上构建对象和数组 --- **不会分配内存**
- no_throw new ： 不爬出异常的new
- `new[]` ： 是分配数组对象的方式

## 内存分区

- 代码区
- data区  --- 全局变量和静态变量
- bnss区  --- 未初始化的全局变量
- 堆 ： 动态分配内存
- 文件映射 ： 存储动态链接库 + mmap函数进行文件映射
- 栈区 ： 临时变量 + 局部变量
- 内核区 

## 段错误

- 访问了**不存在**的内存
- 访问量**受保护**的内存
- 修改**只读**变量
- 栈溢出
- new 一次 delete 多次

## 移动语义 + 完美转发

移动语义： 某个对象持有的资源或内容转移给另一个对象。  必须使用 `std::move` 将左值转化为右值

**完美转发** ： 完美转发是指在函数模板中以最完美的方式将参数传递给另一个函数，保持原始参数的类型和引用属性

- **转发引用** ： 万能引用， 在模板方法中 使用右值引用类型，表示既可以绑定左值，也可以绑定右值。因此可能出现引用类型的变化。
- `std::forward`  标准库函数模板， 用于保持参数的值类型并进行转发

```c++

#include <utility>
#include <iostream>
 
void process(int& x) {
    std::cout << "Lvalue process: " << x << std::endl;
}
 
void process(int&& x) {
    std::cout << "Rvalue process: " << x << std::endl;
}
 
template <typename T>
void forwardToProcess(T&& arg) {
    process(std::forward<T>(arg));
}
 
int main() {
    int a = 42;
    forwardToProcess(a);           // 转发左值
    forwardToProcess(42);          // 转发右值
    forwardToProcess(std::move(a)); // 转发右值
    return 0;
}
```

## 四种 cast 强制类型转换

`static, const, reinterpret, dynamic`

1. static : 用于隐式转换
2. const ： 用于移除变量的  const 
3. dynamic ： 向下类型转换， 只能转 指针和引用， 用于包含虚函数的类
4. reinterpret ：用于将类的指针转化为任何其他类型的指针， 不安全， 可以向上转为父类，向下转为子类

注： static_cast 地址不会改变


## 指针 --- 不同类型

```c++
int *p[n] // 指针数组

int (*p)[n] // 指针 指向的东西确定， 
int (*p)[10] // 行指针， 指向一行有10个元素的指针

int *p() // p为函数 返回 int *
int (*p)() // 函数指针，  int func()
```

## volatile

和 const 对应， 表示变量可以被编译器位置因素更改(如操作系统，或者其他线程)

## 智能指针

shared_ptr  计数器
unique_ptr  本质：构建类， 自动执行析构
weak_ptr
auto_ptr

## 指针常量 常量指针

常量指针， 指向可以改变，但是内容不可改变      `const int *p`
指针常量， 指向不可改变， 内容可变   `int * const p`

## c++ 编译过程

预处理-编译-汇编-链接

## 内存空间

堆，栈，全局/静态，常量存储区，代码区

## inline 内敛函数

避免相同函数重写多次的麻烦，减少了运行时间但是增加空间开销

## 虚表/虚表指针


虚表本质上是一个数组，存放所有的虚函数指针，如果弗雷的虚函数没有被重写，子类虚函数的指针指向的就是弗雷对应的虚函数指针。否则指向子类重写的函数。这就是动态绑定

## 拷贝和复制函数的形参不能使用 值传递 --- 必须传递引用

因为会不断循环

## STL 分配器

主要用于内存管理，主要职责就是 ： 申请空间， 释放空间

1. 内存配置先 allocate 然后 使用构造函数
2. 释放：先使用析构函数，然后 deallocate

## STl 两级分配器

1. 对于 大于 128B 的内存申请 采用一级 分配器 使用 malloc realloc free 进行内存空间分配
2. 对于 小于128B的内存申请， 采用内存池技术， 内部再用 链表进行管理

## C++ 内存池技术

对于小对象， 先申请一定数量指定大小(8B) 的内存块，当新内存申请的时候就拿出一个，不够再申请

算法

1. 申请一个内存区，将内存中按照对象大小划分为多个 内存块 block
2. 维护一个空闲内存块链表，通过指针相连，标记头指针为第一个空闲块
3. 每次新申请一个对象的空间， 就将内存块分配出现， 更新空间的头指针
4. 释放将该内存加到空闲链表头
5. 如果内存区满了， 就开辟一个，维护一个内存区的链表，同样使用指针相连。

## c++ 线程同步机制

## c#线程同步机制

