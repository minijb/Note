
## 左值右值

1. 性质 ： 左值有地址，右值没有地址
2. 右值的作用 ： 用于表示一个临时的值，右值引用允许我们捕获将要被销毁的临时对象，从而避免不必要的拷贝操作
3. 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象； 而临时对象有两个特点。

**右值**
- 该对象将要被销毁；
- 该对象没有其他用户再使用它。

**move操作具体如何实现 ：** 
把被move的复制给move的对象，再销毁原来的。

**被move的内容如何销毁**
- **析构过程**：当源对象被销毁时，析构函数会检查资源指针。如果资源指针为 `nullptr`，说明资源已经被转移，不会尝试释放资源（避免重复释放）。


```c++
string temp = move(str);
// str 就空了
```


**指针和引用的区别**
指针是一个变量，存储的是一个地址，指向内存的一个存储单元；

引用是原变量的一个别名，跟原来的变量实质上是同一个东西。

**检测工具**：

valgrind， gdb


**哈希扩容:**

不止是没有空位置需要扩容，当哈希表被占的位置比较多的时候，冲突概率高，也要进行扩容。

怎么扩？有一个增长因子的概念，也叫作负载因子，就是已经被占的位置与总位置的一个百分比，比如一共十个位置，现在已经占了七个位置，就触发了扩容机制，因为它的增长因子是0.7。

扩容不是简单把数组扩大，而是新创建一个数组是原来的2倍，然后把原数组的所有Entry都重新Hash一遍放到新的数组。重新Hash就是：因为数组扩大了，所以一般哈希函数也会有变化，这里的Hash也就是把之前的数据通过新的哈希函数计算出新的位置来存放。


**平衡二叉树的左右旋转**

行，好的，说一下，比如说平衡二叉搜索数的时候，说一下它的旋转操作吧。

https://blog.csdn.net/yyg15/article/details/108734326
https://blog.csdn.net/qq_37934101/article/details/81160254

**HTTPS 的加密过程** 

**行，就是比如说非对称加密和在刚刚那个过程中哪些是非对称加密，哪些是对称加密，这个知道。**

非对称加密：用于密钥交换和身份验证，常见算法有RSA、ECDSA

非对称加密即加解密双方使用不同的密钥，一把作为公钥，可以公开的，一把作为私钥，不能公开，公钥加密的密文只有私钥可以解密，私钥加密的内容，也只有公钥可以解密。

**注：**私钥加密其实这个说法其实并不严谨，准确的说私钥加密应该叫私钥签名。因为私密加密的信息公钥是可以解密的，而公钥是公开的，任何人都可以拿到，用公钥解密叫做验签。

服务器 ： 私钥 ， client ： 公钥。  传输安全 ：**数字证书，解决公钥传输信任问题**

https://blog.csdn.net/sunyctf/article/details/127702235

对称加密：用于实际数据传输，常见算法有AES、3DES， 直接对报文加密

**静态多态， 动态多态**

静态 ： 重载
动态 ： 重写


**虚表这列**

虚函数表：编译器产生的，存储在**只读数据段**
虚函数指针，存放在类中， 在构造函数执行的时候动态绑定。

重载问题 ： 只有两种情况 ： 函数名称和参数列表。


报错： 但是报错是在编译的时候就报错了的，能检测出来
如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。

**sort函数**

原理是快排进行分段递归， 递归深则堆排序， 递归的范围小则使用插入排序。

**哈希表扩容**

- 增长因子 ： 0.7 ， 检测 ： 占用，冲突率
- 扩容
	1. 先扩容两倍
	2. 然后将所有的元素重新进行哈希放到数组中。

## 递归深怎么办

递归过深，则强制切换算法，比如 stl 的sort

## sizeof

main 中 字符串， 该多少就多少
参数 --- 指针

## lambda

其实就是一个可执行的函数

## 参数 char *

需要 `**` , 或者 引用同理 单个引用没用。

## 虚表，虚基类指针，



## C++ 继承对象模型

### 普通对象总览


- 虚函数
- 非虚函数
- 非静态成员变量
- 静态成员变量

![700](https://s2.loli.net/2025/03/21/FgBhKMUOfZQ5aTc.png)


大小 16 ： `_x`  8  + 虚函数表 4  --- 额外4字节是对齐

> **vs中默认的值是8   Linux中默认的值是4**

虚函数表 ： 虚函数地址+type_info。

**静态成员函数+非虚函数+构造函数 ---- 不在对象中，独立于单个实例化对象**

**函数不在对象的原因** ： 防止对象过大，

c++ 空类的对象至少未 1 字节


![700](https://s2.loli.net/2025/03/21/YOFKq5IAihTWmoM.png)


### 数据成员的声明顺序与内存布局

非静态成员变量在内存中的顺序和声明顺序是一致。

![700](https://s2.loli.net/2025/03/21/JiwbFnkTsjAE3Dx.png)


![700](https://s2.loli.net/2025/03/21/HLN57SVDJOqc2IC.png)

### 继承下的对象布局


#### 单继承

![700](https://s2.loli.net/2025/03/21/Qyx7LaZq5ztrCBb.png)


![700](https://s2.loli.net/2025/03/21/7xX52bzklqsaDOM.png)


#### 多重继承

![700](https://s2.loli.net/2025/03/21/dSiEcFj1WrHJyAN.png)


#### 单继承+多态

![700](https://s2.loli.net/2025/03/21/UKy51DBj6nGdpec.png)


可以进行强制转换。

### 多继承中的虚表+ 虚继承

https://blog.csdn.net/Misszhoudandan/article/details/80190836


D类中有三张虚表，一张是A的，里面放的是B和C继承了A了虚函数，一张是放B自己的虚函数和D中独有的虚函数（因为D是先继承了B），一张是放C自己的虚函数。


#### 虚基类表

虚继承而来的子类会生成一个隐藏的虚基类表指针（vbptr），在Microsoft Visual C++中，虚基类表指针总是在虚函数表指针之后，因而，对某个类实例来说，如果它有虚基类表指针，那么虚基类表指针可能在实例的0字节偏移处，也可能在类实例的4字节偏移处（该类没有vptr时，vbptr就处于类实例内存布局的最前面，否则vptr处于类实例内存布局的最前面）。 一个类的虚基类表指针指向的虚基类表，与虚函数表一样，虚基类表也由多个条目组成，条目中存放的是偏移值。第一个条目存放虚基类表指针（vbptr）所在地址到该类内存首地址的偏移值，由第一段的分析我们知道，这个偏移值为0（类没有vptr）或者-4（类有虚函数，此时有vptr）。我们通过一张图来更好地理解。 


https://zhuanlan.zhihu.com/p/596288935 ！！！