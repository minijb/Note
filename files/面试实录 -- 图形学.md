
**顶点着色器和像素着色器的作用？**

顶点 ：顶点着色器主要负责处理三维模型的顶点数据。它会对每个顶点进行一系列的数学运算，以确定顶点在屏幕上的位置。
像素着色器 ： 光栅化
Fragment Shader： 它在光栅化阶段之后被调用，对每个片元（fragment）进行处理。片元是光栅化后的图形的每个像素片段，包含了位置、颜色、纹理坐标等多种信息
 

**这些着色器的输入输出是什么？**

**顶点着色器** ：
输入
- 每个顶点的原始数据，如位置、法线、纹理坐标
- 常量数据，如变换矩阵
输出： 
- 处理后的顶点属性，如变换后的顶点位置、着色后的颜色和纹理坐标等。这些属性将被插值并传递给后续的像素着色器。


**像素（片元）着色器**
输入：
- 光栅化阶段生成的片元信息，包括颜色、纹理坐标、深度值、法线信息等。
 输出：
- 每个像素的最终颜色值。此外，还可以输出其他数据，如深度值或自定义数据（在延迟渲染等高级技术中）。

**如何实现3D涂鸦**

https://www.bilibili.com/video/BV17wUoYUE5y/?spm_id_from=333.1387.homepage.video_card.click&vd_source=8beb74be6b19124f110600d2ce0f3957

1. 拿到 render Texture。 

如何画？
输出顶点的UV坐标，而不是MVP坐标，并使用renderTexture输出到内存中。
像素的世界坐标 和 当前鼠标的世界坐标进行距离计算，如果足够小。则说明当前的像素在鼠标点击的周围。 ---- 设置像素的颜色。

如何记住？
使用缓冲。`_paintingRT`, 使用 commandBuffer.Bilt 将新绘制的内容添加到 其中以实现叠加。
// 另一种方法 --- 直接内存中添加一个 `color[]` --- 用于画板。


不能快速使用 --- 很多个点
- 分为多个类型， 画点，画线(补间)

uv 接缝的问题。
- bleed

与meshcollider 的问题， 人物动了但是 collider 没动，导致点击的坐标有问题
- 使用 skin mesh render， 每一帧的网格信息 bake 出来

默认形状重复使用uv 的问题
- 使用blender 的 cube

**command buffer**

https://zhuanlan.zhihu.com/p/400977346
https://blog.csdn.net/u012740992/article/details/88795640


## 碰撞检测

https://zhuanlan.zhihu.com/p/571357884

**一、包围盒检测**

1. **轴对齐包围盒（AABB - Axis - Aligned Bounding Box）**
    
    - **原理** ：这是一种最简单的包围盒形式。它的六个面分别平行于坐标轴，即在 3D 空间中，它的前面和后面平行于 y - z 平面，左面和右面平行于 x - z 平面，顶面和底面平行于 x - y 平面。在 2D 空间中，它的四条边分别平行于 x 轴和 y 轴。
        
    - **举例** ：假设有一个 2D 的游戏角色，它的位置用坐标（x，y）表示。角色的 AABB 可以通过角色的最小 x 坐标（xmin）、最大 x 坐标（xmax）、最小 y 坐标（ymin）和最大 y 坐标（ymax）来定义。如果另一个物体的 AABB 与该角色的 AABB 在 x 轴和 y 轴方向上都有重叠，那么就可以判断它们发生了碰撞。例如，物体 A 的 AABB 范围是 xmin=1，xmax=3，ymin=2，ymax=4；物体 B 的 AABB 范围是 xmin=2，xmax=4，ymin=3，ymax=5。在 x 轴方向上，它们的重叠范围是 [2，3]，在 y 轴方向上，重叠范围是 [3，4]，所以它们碰撞。
        
    - **优点** ：计算简单，检测速度快，适用于对速度要求较高的游戏场景，如快节奏的街机游戏。
        
    - **缺点** ：精度较低，可能会出现物体实际上没有接触，但由于包围盒重叠而被判断为碰撞的情况。
        
2. **有向包围盒（OBB - Oriented Bounding Box）**
    
    - **原理** ：与 AABB 不同，OBB 可以根据物体的形状和方向进行旋转。它是通过对物体的顶点进行线性变换，使得包围盒能够更好地贴合物体的形状。在 3D 游戏中，OBB 通常使用变换矩阵来定义其方向和位置。
        
    - **举例** ：在赛车游戏中，赛车的车身形状不规则，并且会根据赛道的方向不断变化。使用 OBB 可以为赛车创建一个能够紧密包裹车身的包围盒，这个包围盒会随着赛车的转向而旋转。当两辆赛车的 OBB 发生重叠时，就判断它们碰撞。例如，赛车 A 的 OBB 通过变换矩阵定义了它相对于世界坐标系的方向和位置，赛车 B 也是如此。通过计算这两个 OBB 的相对位置和方向，判断它们是否重叠。
        
    - **优点** ：比 AABB 更精确，能够更好地适应物体的形状，减少误判碰撞的情况。
        
    - **缺点** ：计算相对复杂，检测速度比 AABB 慢。
        
3. **球形包围盒（Sphere Bounding Volume）**
    
    - **原理** ：它以一个球体来包围物体，球心通常是物体的质心，半径根据物体的最大延伸程度来确定。在 3D 空间中，判断两个球形包围盒是否碰撞，只需要计算它们球心之间的距离是否小于两个球半径之和。
        
    - **举例** ：在一款太空射击游戏中，飞船可以近似看作一个球形。假设飞船 A 的球形包围盒半径为 r1，球心坐标为（x1，y1，z1）；飞船 B 的球形包围盒半径为 r2，球心坐标为（x2，y2，z2）。如果 sqrt（（x2 - x1）^2 +（y2 - y1）^2 +（z2 - z1）^2）<r1 + r2，那么两艘飞船碰撞。
        
    - **优点** ：计算简单，对于形状比较接近球形的物体（如球类游戏角色、子弹等）非常适用。
        
    - **缺点** ：对于形状不规则的物体，可能会出现较大的误差，包围盒可能会包含很多空白区域，导致误判碰撞。
        

https://zhuanlan.zhihu.com/p/176667175  凸多边形
空间划分。
离散碰撞检测（DCD）：离散碰撞检测（Discrete Collision Detection, DCD）只查询某一时刻两个物体是否发生相交，其直接输入为一个三角形和一条边，更复杂的输入都可以由三角形-边组合而来。
连续碰撞检测（CCD）：连续碰撞检测（Continuous Collision Detection, CCD）的基本输入是点-三角形，边-边。更复杂的输入由这两种情况组合而来。
https://zhuanlan.zhihu.com/p/451243910


**为了解决什么问题，为什么会有延续和离散呢？**

因为就是速度比较快的物体，它如果说你逐帧检测的话，它可能比如说它跑去比较快，比如说子弹这一针在这里，然后下一针这里了，但中间这里有一堵墙或者什么东西要碰，要检测的，但是实际它在他没有，就是因为下一次他已经到这里了，所以就没有碰到，所以他就会有这个问，就会可能就会碰不到。就说他没有检测到这个碰撞，然后就直接穿过去了，这种感觉，这种。


**碰撞 ： 分离轴定 --- 的用途就是去检测并判断两个图形之间是否有间隙**


https://blog.csdn.net/yorhomwang/article/details/54869018


原理 ： 假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？

如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。


*如何在代码中实现*

这是一个简易但比较啰嗦的方法，以下是基本的步骤：

步骤一 ： 从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。
步骤二：循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点）， 第二个同理
步骤三：分别得到这两个多边形的投影，并检测这两段投影是否重叠。
如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。

*如何处理圆形？*

- 最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。

*优点*

（译者：原来老外也喜欢先谈优点啊～>～）

- 分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。
- 分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……）

*不足*

- 分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。
- 分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。


**mipmap**

图像距离元了会有一个走样的一个情况，应该是它会有锯齿状的那种形式出来说，因为它的采样率跟实际的图片的分辨率应该是不匹配的，所以就是说会有通过mipmap，就是说它生成不同尺寸的这种相同的图片，然后就是说根据不同的情况去调整它应该使用哪个尺寸的图片，然后来达到消除锯齿的目的。还有就是增大包体，大约原来大小的1.33倍。能减少传输的带宽，消除像素的闪烁。



**渲染顺序**

顶点
曲面细分
几何
裁剪
图元装配 ： 三角形朝向剔除
光栅化
片元


