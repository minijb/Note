---
tags:
  - 面试
---
# 注意点

1. 不适用 float 
2. 不建议使用 多线程 


单机模式  ：  input -> update -> stop
状态同步 ： Server  计算结果返回 client
帧同步 ： 服务器到时间点就发送  没有input 就发空白， client 接受到服务器的消息进行 step
(自己的输入不进行模拟， 而是等到服务器的输入进行模拟)


client ： 两个buffer ： LBuffer ， SBuffer (本地 + 服务器)
client update 的数据 ： SBuffer

问题 ： client 比 服务器快 (如果服务器没到， 则使用本地进行模拟， 到了就用服务器的)

**例子**  --- 预测回滚 

client ： 7   server： 2 

此时 client 返回到 1结束的状态， 根据输入2进行模拟。

**回滚涉及：**  copy and recover。 备份和还原

如何回滚 ： 1. 手动， 2. 反射 3. 代码生成 4. memcpy 内存拷贝。

1. 太麻烦
2. 性能问题
3. 推荐
4. 需要内存紧凑

Recover ： 需要 业务层的绑定
实现 ： 1. 写入文件 2. 使用命令模式

**跨平台， 多实例**

A，B ： 需要是static  也就是单例模式。

**Debug** ：

- 帧同步 ： dump 帧状态， 帧执行过程： 行为日志。 需要查看两个c1,c2的日志就可以查看问题。
- 预测回滚 ： 使用 Dict 存储 <状态， 输入， 行为>， 回滚的时候 老的dump 到单独的，存储只有最新的。 (使用 diff 进行定位)

## 王者 帧同步 https://www.bilibili.com/video/BV1jD4y1C7MK?p=7&vd_source=8beb74be6b19124f110600d2ce0f3957


服务器 ： 收集玩家操作阶段 -> 到固定时间 -> 发送给所有玩家 
客户端 ： 收到服务器操作 -> 计算逻辑 -> 上报下一帧给服务器

比赛开始 ：

**服务端**

- frameid 帧率的 id 。下一帧要进入的id ： frameid = 1；
- match_frames : 在服务器上用来保存所有玩家每一帧的操作。**可以用来录像回放 + 断线重连 + 丢包时序问题**
- next_frame_opt : 保存收集到的用户操作帧。
	- frameid ： 下一帧的 id
	- opts ： 收集到的操作集合操作集合
- 定时器 ： 每隔66ms进行一次**帧操作**
- 注意 ： 开始后5s给客户端切换场景的时间。
- **帧操作**
	1. opts 集合中的帧保存在 match_frames
	2. 遍历所有玩家 + 发送操作
- 进入收集阶段，清空 next_frame_opt 中的物体


**发送服务器认为 玩家没有同步的帧**  ： 每个玩家对象上都有一个 sync_frameid --- 玩家已经同步的帧
- 发送 `sync_frameid + 1 - 最新的帧` 
- 用于应对 UDP 丢包问题，进行补发。  
- 收到 player 的 帧 id != next_frame_opts.frameid 说明收到过时的帧， 直接丢弃！！！ (会影响手感吗？ 会但是影响小)

**客户端**

- 客户端收到数据包后， 使用 `on_Logic_update` 进行逻辑更新
- 每个客户端 都有一个sync_frameid, 记录当前客户端已经同步到的帧。
-  如果  receieved id < local id : 则 丢弃 
	1. 出现这种情况的 **原因** ： UDP 存在 先发后到/后发先到
	2. 收到 99 . 开始处理100. **能否同步**
		- **可以**  ： 因为 此时我们已经进行了 **帧的重传， 也就是说， 执行100帧的时候 已经进行了重传，那么就无需理会 99这些之前的帧了  发送的是  99-100**  简单来说 --- 就是说 如果99必定已经补发过了
- 如果上一个帧 is not null **在处理下一帧的时候，必须先同步上一个帧的结果**
	- 在播放动画的帧于帧之间， 会出现时间的差异，进而导致不同步。
	- **logic_pos ： 66ms， 以此为依据进行位置和结果的迭代**

A：| --- 63 ---- |
B: | --- 60.5--- |

同样的操作：处理的时间不一样！！！

![700](https://s2.loli.net/2024/09/16/fM9txiX5cvwUqpA.png)

![700](https://s2.loli.net/2024/09/16/fuFIRx5sPoaGkgL.png)


- **跳帧率** ： 从旧帧快速同步完新帧 ， 90 --- > 100 **直接使用一个循环进行对结果进行迭代。进而实现帧同步**

![700](https://s2.loli.net/2024/09/16/u3XSOFAJI6MWGd8.png)

- 控制客户端根据操作播放动画 ：更新我们的逻辑推进

![700](https://s2.loli.net/2024/09/16/rliIZs7Y5WoECJ3.png)
- 采集自己的操作，上报给服务器 是自己认为的下一帧（不是真正的下一帧）  `capture_player_opts`
	- **如果 自己上传的帧 比 服务器慢！！！！！！！**
	- 则对这个帧进行更新

**客户端**
![700](https://s2.loli.net/2024/09/16/bpDgc2Vu8EXhkSx.png)


**服务端**

![700](https://s2.loli.net/2024/09/16/d7tm62cJsvBz5ro.png)

**例子**  ： 服务器收到玩家已经处理的帧id

server ：98(处理完成), 99 - 发送 -> client,  client 处理 99， client - 上传 100 -> server ,  

**server 收到 100帧， 这就意味着， 99 已经同步完成了**


server 中 ： 将 98 改变为 99
- 保存 玩家的操作 ： 并等待下一帧的触发


### 克服丢包


客户端：丢包，服务器会补发丢弃的帧/还没到的帧。
服务端丢包 ： 没有太多影响， 下一帧就可以处理。