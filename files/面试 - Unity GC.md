---
tags:
  - 面试
---
## Unity GC

代码位置 il2cpp 目录下的GC目录 BoehmGC

## BoehmGC

把系统函数 malloc 替换为 `GC_malloc` ，之后不需要管理如何 free了


## BoehmGC

每次批量申请 4k 倍数大小，除了用户能使用的内存之外，还有 BoehmGC 内部维护的数据结构 (GC_scratch_alloc) 分配

**核心** ： 分级结构 ，每次申请根据内存大小归类成 小内存对象和大内存对象。
**依据** ： 不超过 PageSize/2 也就是 2048 字节的对象为 小内存对象， 反之则为大内存对象

> 重要

**对于大内存对象**  向上取整到4k的倍数大小的内存块
**对于小内存对象** 先申请一个内存块， 而后在这个内存上进一步**细分为 small objects 形成 free list**


## 内存管理策略

思想 ： 物以类聚

**管理内存的最小粒度** ： Granule。 32位 值为8字节， 64位 位 16字节(用户申请10字节，也会被调整位16字节)
一个 hblk 如果不属于 大内存对象， 那就是容纳了若干个**等大小的 small object**

**对于大内存对象** 按照对应的 hblk 数， 把他们归类到若干 freelist 中。
**当大内存对象被回收的时候** 会尝试将 hblk 合并 减少内存碎片。

**对于小内存对象的大小分档** ： 不完全按照 Granule 的等差数列来决定。 临近的大小会被优化合并，如存在很多 1024 字节的闲置块，但申请1008字节的小内存对象仍然可能miss， 此时使用 1024 的块时最好的选择，适当合并临近的 block size 可以优化内存分配。 参考 `GC_init_size_map, GC_extend_size_map`


## GC 优化

### 1. 装箱

装箱：就是将值类型，转换为 应用类型。拆箱 ： 相反

**过程**

1. 在堆中分配内存，大小：**原始的内存量+两个额外成员 ( 类型对象指针， 同步块索引 )**
2. 值类型，复制到新分配的堆内存中
3. 返回对象的地址，就是这个对象的引用

### 2. 使用泛型优化装箱

有一些方法的参数不确定的时候 使用Object 
使用泛型可以避免这个问题。

### 3. 字符串

字符串时不变的