---
tags:
  - 面试
---

## 多线程

### 进程和线程

**进程** ：
定义：
- 操作系统中的执行实例
- 包含程序代码、数据和资源
- 是操作系统分配资源的基本的那位
- 有独立的地址空间
- 切换开销大
- 需要操作系统调度
- 通信复杂，需要借助操作系统的支持如共享内存，管道，消息队列等

**线程** :
定义：
- 进程中的执行单元
- 共享进程的地址空间和资源
- 各自持有程序计数器和栈空间
- 创建销毁快
- 切换开销小
- cpu的基本执行单位
- 由cpu调度
- 通信简单，可以使用共享变量


### 什么时候使用锁, 什么时候使用原子变量

都是同步机制

**锁的使用场景**

- 保护长时间访问的临界区 -- 如复杂操作如链表,树
- 多个共享资源的同步访问
- 复杂操作 -- 一次更新多个变量

**锁的类型**

- 互斥锁 -- 保护一个共享变量
- 读写锁 -- 多个读者并行访问, 单个写者独占
- 自旋锁 -- 短时间持有锁, 线程不轮询

> 自旋锁 : 原地等待. (而不是挂起)
> 用于避免中断上下文.

**原子变量使用场景** 

- 短时间操作 : 简单的证书增减, 标志位切换
- 上下文切换/锁的开销过高 -- 性能关键场景


- 不会导致线程挂起等待锁释放 更加轻量 -- 非阻塞算法

使用 : 

- `std::atomic`
- Lock 前缀

### 线程池

**功能需求**

1. 动态提交任务 ： 提交任务到任务列表
2. 指定线程数量 
3. 开启关闭调度 ： 启动和停止线程调度

**实现步骤**

1. 定义任务类型或接口
2. 管理线程生命周期 ： 维护线程池
3. 存储待执行任务 ： 维护任务队列
4. 向队列添加任务 ： 提供提交任务的接口
5. 利用互斥锁，条件变量等， ： 实现线程同步机制

**1. 定义任务**

使用 `std::function<void()>` 表示任务类型， 使用 void 函数执行

**2. 创建线程池类**

1. 使用 `std::vector` 存储线程 ： 线程数组
2. 使用 `std::queue` 存储任务 : 任务队列
3. 指定线程池大小 ： 通过构造函数传入线程数量

**3. 任务提交接口**

以线程安全的方式添加, 锁定任务队列。

**4. 线程获取并执行任务**

1. 从任务队列中获取任务 ： 确保线程安全
2. 使用互斥锁执行任务

**5. 提供线程池管理方法**

启动，关闭，清理
std::thread, join, 释放资源

https://www.bilibili.com/video/BV1VcmGYmEtW?spm_id_from=333.788.player.switch&vd_source=8beb74be6b19124f110600d2ce0f3957

**一些代码**

```c++
#inlcude <functional>

using Task = std::function<void()>;

class Threadpool{
public:
	explicit ThreadPool(size_t numThreads);
	~ThreadPool;
	void enqueueTask(const Task& task);
private：
	std::vector<std::thread> workers;
	std::queue<Task> tasks;
	std::mutex queueMutex;
	std::condition_variable condition;
	bool stop;
}


//enqueue
std::unique_lock<std::mutex> lock(queueMutex);
task.push(task);
condtion.notify_one();

void ThreadPool::workerThread(){
	while(true){
		Task task;
		{
			std::unique_lock<std::mutex> lock(queueMutex);
			this->condition.wait(lock, [this]{
				return this->stop || !this->task.empty();
			});
			if(this->stop && this->task.empty()) return;
			task = std::move(this->task.front);
			this->tasks.pop();
		}
		task();
	}
}

ThreadPool::ThreadPool(size-t numThreads) : stop(false){
	for(size_t i = 0 ; i < numThreads ; ++i){
		workers.emplace_back([this]{this->workerThread();});
	}
}

~ThreadPool::ThreadPoll(){
	{
		std::unique_lock<std::mutex> lock(queueMutex);
		stop = true;
	}
	condition.nofify_all();
	for(std::thread &worker : workers){
		worker.join();
	}
}
```

### 进程通信方式

1. 消息独立额
2. 信号
3. 文件
4. 管道
	- 匿名管道 ： 用于父子进程中通信 -- 单向
	- 命名管道 ： 双向管道， 用于无亲缘关系的进程
5. 共享内存
	- 多进程同时访问，不需要拷贝缓冲区，
	- 需要信号量等同步机制，防止竞争条件
1. 套接字

### 内存序

这些内存序提供了不同级别的同步保证，可以帮助我们在多线程程序中实现更精细的控制。 主要结合原子操作进行

- memory_order_relaxed --- 仅保证原子操作的原子性，**最弱** 不保证同步
- memory_order_consume --- 仅在数据依赖操作中有序， **已被代替**
- memory_order_acquire --- 读取操作之前素有操作限制性，**用于获取锁或同步操作**
- memory_order_release --- 写入操作之后，所有操作先执行，**用于解锁操作，确保操作完成**
- memory_order_acq_rel --- 结合 acq和 rel， **适用于 读，改， 写操作。如 CAS操作**
- memory_order_seq_cst --- 最强，**保证全局顺序** ，默认选择，适用于严格顺序的场景

https://blog.csdn.net/sinat_28305511/article/details/131257757

### 线程和携程

**线程使用场景** ： CPU 密集任务， IO密集任务(网络请求，文件读写)， 利用多核处理器进行并发执行

优势 ： 真正的并行
劣势 ： 资源开销大，同步机制复杂
场景 ： 数据压缩， 视频渲染， 科学计算

**携程的使用场景** ： 可以方便的暂停和恢复执行
- 轻量级任务切换， 如异步任务处理、网络服务器。
- 高并发处理： web服务器，大量并发请求
- 复杂控制流 ： 状态机处理，多步骤操作

优势 ： 高效任务切换， 逻辑控制简单，避免回调
劣势 ： 不是真正的并行， 缺少库支持
场景 ： 高并发网络服务器，多任务调度器，异步IO

### 有栈协程，无栈协程

**有栈** ： 切换携程时回复整个栈的上下文，
优势：可以直接使用c++栈空间， 适应性强，支持复杂结构化并发操作
劣势：开销大，可能爆栈，需要底层支持如 Boost
适用于 ： 需要复杂栈操作，灵活度要求高。嵌套携程调用和深层递归

**无栈** ： 通过状态机，没有栈， 通过保存状态和局部变量实现 yield 和 resume  --- C++ 20的选择
优势： 内存开销小，切换上下文快， 实现简单
劣势： 灵活性差，不能自由操作栈。
适用于 ： 内存紧张同时需要快速切换上下文， 高并发小任务额度

https://zhuanlan.zhihu.com/p/484820117

### 如何设计一个线程安全的类

1. 使用锁
2. 部分操作可以使用原子变量， 避免锁开销 -- `std::atomic`
3. 使用条件变量，进行多线程协调工作 （满足特定条件后再进行操作） 
4. 使用线程消息队列
	 - 所有操作在一个队列中
	 - 具体操作在线程内

### 死锁

- 互斥条件  -- 减少独占资源， 采用非阻塞同步机制
- 占有且等待 -- 资源预分配，一次性请求所有资源
- 不可剥夺 -- 请求失败释放资源/使用优先级剥夺
- 环路等待 -- 系统资源排序，并按顺序请求资源

### async  的使用场景

**启动策略选择**

- `std::launch::aysnc` 创建新的线程
- `std::launch::deferred` 需要结果时开启任务
- `std::undefined` 未指定策略(默认) ： 调度器决定

**获取结果**

- 调用 `future.get \ future.wait` 获取结果
- 未获取结果可能导致不确定行为

**生命周期**

- `std::futrue` 未被移动或绑定，声明周期结束阻塞
- 异步任务和 `std::future` 对象声明周期绑定

`std::async` 会自动推导返回类型, 在异步任务结束后存储在 `future` 中

**共享结果**

- 使用 `std::shared_future` 共享异步结果
- 多线程访问安全


**异常处理**

-  使用 `future.get` 捕获并处理

**并发任务**

- 其他并发容器 ： `std::mutex, lock_guard, atomic`
- 处理复杂共享数据访问问题

### atomic 原子操作

多个线程可以对一个变量进行操作， 不需要锁

**定义**

- 不可分割，要么完全实行，不要完全不实行

**使用**

- `std::atomic` 修饰的基础数据类型如 int 等


https://blog.csdn.net/qq_46017342/article/details/132838649

**底层实现**

使用 CPU 中的原子指令如 `XADD, CMPXCHG` 保证硬件级别的原子操作

**内存序约束**

memory_order_relaxed 等 保证原子性和同步的顺序， 默认最严格

[[面试现场问题#内存序]]

**与锁比较**

使用场景 ： 适用于计数器或者标志位，对于复杂数据结构 **锁有优势**
原子操作的速度更快  --- 可以减少上下文切换以及数据竞争和中间状态

### 线程局部存储


`thread_local` 关键字 ： 每个线程独立维护变量。

实现 ：

- 通过线程控制快， TCB 实现， 每个线程有独立的TCB和存储数据块指针
- 作用范围 ： 在声明编译单元内
- 声明周期 ： 和线程绑定
- 数据一致性 ： 
	- 每个线程有独立副本， 无数据竞争
	- 多线程共享数据需要额外同步

注意 ：

1. 释放局部存储的内存分配和释放。 
2. 注意线程结束， 变量的生命周期也结束。

### 什么时候用原子变量和锁

锁 ：
- 复杂结构， 多个资源
- 复杂操作

原子变量 ：

- 简单结构
- 需要硬件支持
- 速度更快

### jthread 和 thread 的区别

jthread 自动管理资源 --- 生命周期自动管理，对象销毁自动join
c++20后提供

- 提供终端接口 ， 标准库无真正的终端功能。

### 条件变量为什么要配合锁

**防止竞争条件**
1. 保护共享数据 -- 确保操作原子性
2. 防止虚假唤醒 -- 唤醒后使用锁进行检查
3. 确保一致性 -- 保证修改一致性


**条件变量的工作机制**

1. 期望条件成立 ： 线程调用 wait 方法， 通过锁保证条件检查等待原子性
2. 唤醒后检查： 重新检查条件， 防止条件不满足


## 基础

### STL 内存分配器

前置知识 ： new and delete 

new : 1. 分配内存， 调用构造函数  2. 调用析构函数 ， 释放内存

STL双层内存分配器 ： 

- 对于 大于 128K时， 调用 new ， 也就是一级内存分配器
- 对于 小于 128K时， 采用二级内存分配器 ： [[面试现场问题#C++ STL 内存池|内存池]]。 --- 减少 malloc次数

## C++ STL 内存池

申请一定数量的内存块(8B)，当星的内存申请的时候就拿出来，不够再申请。

算法 ：

- 预申请一个内存区 chunk， 并将之划分为多个 内存块 block.
- 维护一个 内存块 block 链表，头指针为第一个空闲内存块 block
- 每次申请就是将 之 从空闲列表中去除。 更新空闲链表头指针
- 释放就是加到头指针上
- 一个 chunk 满了， 则再开辟一个 chunk

### 什么时候用继承 很么时候用组合 

1. is-a 时使用继承， has - a 使用组合
2. 如果时扩展或者修改基类行为， 推荐使用 继承
3. 组合可以防止耦合， 更加灵活
4. 继承可以实现代码复用。

### enum 和 enum class 区别

1. enum 直接进入作用域 ， enum class 需要枚举名作为前缀 ： `class::enum`
2. enum 类型安全， 成员之间不能隐式转换。
### using 和 typedef 的区别

- using 可以定义模板别名， typedef 不行
- 可以引入命名空间

### 野指针和悬挂指针

都有可能招致不可预测的行为

**野指针**

定义 ： 未被初始化的指针
特点 ： 
- 指向随机
- 可能导致程序崩溃和数据损坏

**悬挂指针**

定义 ： 合法指针被释放或者重新分配
特点：
- 访问的内存会导致未定义行为
- 指向的内存不是预期值

**解决方案**

- 初始化的时候进行初始化
- delete 之后 赋予 `nullptr`
- 使用智能指针

### TCP Read 返回值

= 0 链接挂壁
< 0 发生错误
大于 0 成功读取数据 --- 读取的字节数

< 0 的 error_number
- RAGAIN EWOULDBLOCK 没有数据可以读
- ETIMEDOUT 超时
- EINTR ： 信号中断
- ECONNRESET ： 对方发送 RST 报文 (链接被异常关闭/无法恢复)
- EPIPE ： 写入到已断开连接上

### fork 返回值

大于 0 返回的是子pid ， 当前为父进程
等于 9 当前为子进程 
### c++锁的底层原理

1. 互斥量 mutex
2. 自旋锁 spinlock
3. condition variable 条件变量
4. 操作系统调度器
	- 负责分配 CPU 资源
	- 切换线程以实现锁定

**相关概念**

- 原子操作 不可分割的最小单位
- 死锁

**锁的优化**

1. 读写锁
2. 递归锁：同一线程可以多次获取， 需要相应的解锁
3. 无锁编程。 使用原子操作保证数据的一致性。 如无锁队列和无锁堆栈
4. 内存屏障 ： 多核环境下 防止内存/cpu访问操作重新排序， 保证多线程操作数据的一致性



### 左值和右值

| 左值         | 右值          |
| ---------- | ----------- |
| 可以出现在 = 左边 | 不可以出现在 = 左边 |
| 可以取地址      | 不可以取地址      |
| 变量         | 表示具体的数据值    |
|            | 常量，临时变量     |

- `int a = b + c` 其中 a 是左值 ， (b+c) 表达式没有地址， 因此是一个右值
- 字面量是右值

**左值引用**

- 可以取地址
- 可以使用 const ，使用后不可以修改

**右值引用**

- 表达式右边的必须是右值
- 使用 `std::move` 将左值转化为右值

- 用于处理临时变量
- 避免复制，实现移动语义

**纯右值**

- 运算表达式产生的临时变量
- 不和对象关联的原始字面量
- 非引用返回的临时变量
- lamdba 表达式

- 除字符串字面值外的字面值
- 返回非引用类型的函数调用
- i++，i--
- 算数表达式
- 取地址表达式

**将亡值**

- 和右值引用相关
- `T&&`

应用：

- 移动语义
- 移动赋值

可以避免内存空间的释放和分配， 延长变量的生命周期，用于移动赋值

### 如何避免内存泄漏

**泄漏场景**

- 对象未释放
- 循环引用
- 集合类容器， 删除元素后未释放
- 异常处理，没有手动释放内存
- 静态成员和全局变量，持有动态分配的内存

**如何避免**

- 使用智能指针
- 使用析构函数
- 使用 cppcheck 和 valgrind
- new 和 delete 对应
- 使用 weak_ptr

### 数组和指针的区别

**内存分配** ： 

1. 数组 ： 栈上分配连续内存
2. 指针 ： 一般 8字节。 之后可以动态分配

**固定和动态大小**

数组 ： 大小固定， 数组名是首元素的常量指针
指针， 可以动态分配和释放

**类型安全**

数组 ： 声明的时候绑定类型 ，编译器会进行检查
指针 ： 声明时有类型， 但容易引起类型不匹配

### 迭代器和指针的区别

- 迭代器时模拟的指针操作，可以便利复杂数据类型
- 指针就是地址

**安全性**
- 迭代器，有安全性检查，避免越界访问

**迭代器类型**
- 输入，输出
- 前向，双向
- 随机访问迭代器

**灵活**

- 通过多态和模板：适应勇气类型
- 指针智能指向类型的内存块

**迭代器的实现**

- 封装指针
- 提供操作方法

- 指针时内置类型

**迭代器的可移植性，生命周期**

- 代码具有可移植性， 使用标准迭代器接口无需修改代码
- 指针不行

- 生命周期：考虑容器的生命周期，析构的时候迭代器无效

- 可以进行 `范围for` 循环 

### 函数调用原理与栈帧

函数调用原理：

- 保存上下文 -- 程序计数器-部分寄存器
- 分配栈帧 ： 保存局部变量
- 传递函数 
- 跳转函数
- 执行函数
- 返回调用点

**栈帧**

- 函数参数
- 函数执行完毕后的返回地址
- 局部变量和临时数据
- 保存的上下文

**函数调用栈**

- 栈内存管理
- 栈的创建和释放


### shared_ptr

**引用计数机制**

- 构造，拷贝时 引用 +1
- 析构时 引用 -1
- 引用0时  释放资源

**线程安全**

- 对于引用计数时安全的。
- 但是对于管理的对象， 需要额外的同步机制。

### c++ List

- List 双向链表， 适用于频繁插入
- deque ： 适用于双端快速插入，支持随机访问

**专用成员函数**

- splice 函数 快速将某段元素移动到另一个list 位置
- merge 合并有序链表
- reverse 反转
- sort 排序

**list排序**

- 使用 list 自己的 sort 不可以使用 std::sort

**迭代器**

- 双向迭代器， 可以前后遍历
- 随机访问迭代器 不能使用于 List

### 返回值优化 RVO

编译器在返回值位置直接构造对象， 避免临时对象的创建和析构

**和移动语义有区别** 


### 命名返回值优化 NRVO

针对具名对象的返回值优化。优化掉中间拷贝构造。

### 友元

友元类 ： 允许一个类访问另一个类的私有变量， 不破坏继承
友元函数， 允许函数访问类的寺院成员， 单向访问不破化封装性

### c++ 成员初始化顺序是否固定

顺序时固定的。

按照声明顺序初始化。 构造函数初始化列表不影响顺序。

**注意：**

1. 依赖关系
2. 静态变量的初始化在类定义外进行
3. 初始化列表的应用
4. 继承的初始化顺序。 基类先

### std::array

1. 固定大小
2. 连续内存
3. at() 接口安全
4. 防止越界问题。
5. 接口友好，  size ， begin, end 等 
6. 支持拷贝复制， 提供大小信息 (和 c 数组)
7. 和 vector ： 动态大小

### inline 的作用

允许多次定义而补违反ODR， 可以在头文件中直接定义、。

1. 简化代码组织
2. 避免链接错误
3. 便于维护。 但是不方便维护

https://www.runoob.com/w3cnote/cpp-inline-usage.html

### deque

**分段存储结构**

- 分配若干小块连续内存
- 使用指针数组管理小块内存

**中央控制块**

- 指针数组， 指向小块内存
- 灵活管理内存

**缓存局部性**

- 数据存储在多块内存，
- 频繁访问大量元素缓存命中率不如vector
- 插入和删除操作灵活

**内存增长**

- 分配新的缓存并更新中央控制块
- 扩展时不需要移动现有元素

### explicit 

防止单参数构造函数隐式转换。

### final

- 防止类被继承
- 防止虚函数被覆盖

### 什么时候使用 移动构造函数

- 函数返回对象的时候，避免返回值拷贝
- 函数参数传递， 避免参数拷贝
- 容器间对象移动
	- 将大对象从一个容器移动到另一个容器
	- 避免资源分配和释放


## 类和对象

### 虚函数

虚表 ： 编辑器创建
虚表指针 ： 构造函数中将其指向对应的虚表
因此，构造函数不能够是虚函数，但是析构函数可以（保证父类中的析构函数的调用，防止内存泄漏）。

**不能是虚函数的**

- 构造函数
- 静态成员函数
- 友元函数

**细节**：

- 基类中没有一个 virtual 方法都会在虚函数中添加一个，
- 在编译的过程中，设定好每类的虚函数表
- 在构造函数的时候，将 vptr 和虚表绑定。此时可以通过表找到对应的函数
- 多态：通过找表，找到对应的函数

虚表：存储虚函数地址，如果 override 会进行覆盖，否则指向原本的virtual
虚表指针：一旦类内有 virtual 会自动添加虚表指针
### 列表初始化

使用 `{}` 进行初始化。

范围： 

- 内置类型
- 用户自定义类型
- 容器

优势：

- 方便
- 可以接受任意长度的初始化列表
- 可以避免类型**窄化** (浮点数和整形)

> 窄化转换（narrowing conversion）是指将一个值转换为另一种类型，但转换过程中丢失了信息或超出了目标类型的表示范围的情况
> 使用列表初始化的时候，**如果窄化会报错**

**底层实现 :** `std::initializer_list`

### 栈溢出

1. 栈和堆
2. 出现原因 ： 栈空间耗尽， 无限递归，局部变量过多
3. 递归优化 ： 尾递归优化， 控制递归深度
4. 错误处理 ： 异常崩溃， segmentation fault
5. 工具 ： valgrind ， GDB



### 虚继承

`virtual public A`

解决菱形继承问题。 确保单一实例。

**内存布局影响**

- 类内存结构 - 增加额外指针和控制块， 空间开销增加
- 可以无歧义访问基类成员。

## 杂项

### 如何定位数组越界的位置

1. 使用 asset -- 在 release 模式下是没有的
2. 使用 gdb
3. 使用代码检查工具


## C++ 新特性

1. 智能指针 : `shared_ptr, unique_ptr`
2. 线程库 `std::thread`
3. function 和 lambda
4. auto 类型推导
5. lock : `std::lock_guard  std::unique_lock`
6. 左值和右值

lambda ： 

- 捕获列表
- 参数列表
- 可变规范
- 异常规格
- 返回类型
- 函数体

funciton :

- 通用堕胎包装器
- 存储、复制和调用可调用
- 兼容签名
- 类型擦住

### 日志框架 

- Boost.Log - 编辑时间长
- gLog - 接入麻烦， google 出品
- log4cpp - 老
- spdlog - 快， 功能不如 其他的功能全面 



## 网络

### TCP 半包和沾包

- 半包 ： 只收到一般
- 沾包 ： 一次接受到多个包，当作一个包处理


### 为什么 TCP 需要有 TIME_WAIT 状态

1. 确保 最后的 ACK 被成功接受

为什么等待的时 2MSL ： 1. 防止旧报文干扰， 2. 事件要求 

## Select， Poll ， Epoll

**select** 

- 使用固定长度数组表示文件描述符
- 每次调用会重新构建这个描述符集合

缺点：
-  支持的文件描述符数量有限
-  时间复杂度 O(n) 大规模场景下效率低

**poll**

- 类似 select ，但是使用动态数组存储文件描述符
- 没有最大连接数限制

缺点
- 每次都需要便利
- 大规模不行

**Epoll**

- 提供边缘触发ET和水平触发LT
- 通过事件通知的方式只处理实际发生变化的描述符

优势
- 不需要遍历
- 只需要一次添加操作，管理高效



## 性能优化

### 算法和数据结构的选择

**合适的数据结构**

1. 经常查找 ： 哈希表
2. 频繁插入 ：链表
3. 快速索引 ： 数组

**合适的排序算法**

大规模使用 快排和归并

### 对象管理

1. 减少对象创建和销毁 -- 使用对象池
2. 使用智能指针
3. 多了解内存管理 https://zhuanlan.zhihu.com/p/344377490

### 内敛函数和移动语义

- 短小并经常使用的可以使用内敛 inline
- 移动语义： 减少对象拷贝开销
	- 移动构造和移动赋值

### 多线程和并行计算

- std::async std::future std::thread
- 同步机制 ： std::mutex std::lockguard 

### 编译优化 预编译

- 链接优化 ： 使用 `-flto` 进行跨模块的优化
- `-O2 -O3`

### 代码缓存

**数据局部性**

- 访问相邻内存优化缓存 --- `reserve`
- 排序数组比链表性能好

## 框架

### C++ 网络框架

Bosst.Asio 
- 广泛应用
- 异步IO，搞笑处理并发
缺点： 难学
cpp-httplib
libhv
libcurl

事件驱动：资源占用少， 但是编程复杂
多线程模型 ：模型简单，但是需要同步操作

### 数据库框架

SQLit
sqlit——orm
mysql-connector-cpp
libpqxx

### 内存序



## 设计模式

### 单例模式

**懒汉模式** ： public 静态方法返回实例， 构造函数和拷贝构造函数为 private 
**饿汉模式** :  在程序开始的时候就创建实例， 直接在类中初始化成员

**线程安全** ：

- 使用双重检测机制保证线程安全。 --- C++11后，局部静态变量初始化线程安全

**实例销毁**

- 使用智能指针
- 手动清除

## 图形学

https://www.cnblogs.com/JimmyZou/p/18296317

## C sharp

### 拆箱和装箱

1. 类型转换的时候会发生拆箱和装箱 (值类型和引用类型之间转换)
2. int.tostring 是否会发生拆箱和装箱 ： 不会 
	1. int 是 结构体
	2. tostring 经过重写，不需要使用 Object 的 toString  因此不需要装箱
3. 装箱常见出现在 字符串拼接中 `string + int` 此时 int 会被强制转换为 引用类型

### 为什么泛型可以解决装箱和拆箱问题

泛型指定了类型，传递参数的时候不需要为 object 。


## GC 优化

https://www.yuque.com/chengxuyuanchangfeng/qxodkp/envroun6whqx4x39#tzDOL



## Unity

### Update 函数生命周

fixed update， update ， lateUpdate

相机放在 update 容易造成抖动问题


fixed update 使用定时器运行

### 如何屏蔽按钮

1. 禁用 physic raycast
2. 删除所有事件
3. 禁用按钮的 interactable 属性
4. 直接覆盖



### UGUI 渲染顺序

https://www.yuque.com/chengxuyuanchangfeng/qxodkp/dnolr5y57fiaifo9#rC5fH

##  Lua -- 有点忘了

### 原表 ！！！！

https://www.runoob.com/lua/lua-metatables.html
https://www.yuque.com/chengxuyuanchangfeng/qxodkp/xoheyuod8tpbr5uo

