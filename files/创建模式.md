
## 工厂方法模式

父类提供创建对象的方法，子类决定实例化的对象的类型。

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用（使用接口，子类进行继承）。

原本创建汽车，如果想要创建轮船，只需要写一个船的子类就可以了。 --- 这里就是两个对象都实现 Transport

**注意：** 生产的类型，需要简称一个共有接口！！！

![700](https://s2.loli.net/2025/03/07/MCeT46hktS9NcqR.png)


## 抽象工厂

它能创建一系列相关的对象，而无需指定其具体类。

注意生产的产品也是一个抽象。  --- client 只需要知道拿到对象有具体的接口就可以了。

![700](https://s2.loli.net/2025/03/07/C14LbthrkV58jl7.png)

## 生成器

使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。

如果 new 的过程中需要大量的参数（有些有用，有些没用）

![700](https://s2.loli.net/2025/03/07/IouAYkH7LXsJthp.png)


![700](https://s2.loli.net/2025/03/07/afiuUNVbJI1APHO.png)


可以用来避免 **重构构造函数**， 避免构造函数的参数过多，以及大量的构造函数重载。
功能也类似，工厂方法。

- 生成器重点关注如何分步生成复杂对象。抽象工厂专门用于 生产一系列相关对象。抽象工厂会马上返回产品，生成器则 允许你在获取产品前执行一些额外构造步骤。
- 在许多设计工作的初期都会使用工厂方法（较为简单，而且 可以更方便地通过子类进行定制），随后演化为使用抽象工 厂、原型或生成器（更灵活但更加复杂）。

## 原型模式

你能够复制已有对象，而又无需 使代码依赖它们所属的类。


![700](https://s2.loli.net/2025/03/07/glqwOZsuHLbfyi6.png)



如果子类的区别仅在于其对象的初始化方式，那么你可以使 用该模式来减少子类的数量。别人创建这些子类的目的可能 是为了创建特定类型的对象。

> - 原型可用于保存命令的历史记录。
> - 有时候原型可以作为备忘录的一个简化版本，其条件是你需 要在历史记录中存储的对象的状态比较简单，不需要链接其 他外部资源，或者链接可以方便地重建。

## 单例

- 全局唯一
- 为该实例提供一个全局访问节点