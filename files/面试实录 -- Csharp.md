
**默认接口方法**

接口中的函数，可以写上默认函数。

**委托**
委托的话它其实本质上是个类，然后包括像他写的他类似于函数指针，就是说他持有多个相当于是多个方法作为一个变量，常用的话就是说比如说在观察者模式里面，或者说作为回调函数，那就是委托常用的一个情况，就是说比如说某些条件触发了以后，然后我通知到这些被关心委托的类，然后去通知他们去执行对应的回调函数这块，然后还有事件，

事件的话，它就是对于委托的一个进一步封装，但它跟委托也有一定的区别就是说首先委托它是可以在命名类之外声明了，并且它谁都是可以去调用委托，但是对于事件来说，我只有声明这个事件这个类才能去。

其次的话事件就是说它只支持就是说订阅和取消，也就是加等于和减等于操作。但是委托的话，我可以比如说直接等于某一个方法，它在实际的开发当中的话会有问题，
比如说开发的人多了以后，他可能不知道，有些人不知道就是说委托他具体订阅哪些方法，它可能就一个等于号，就直接把之前别人订阅的方法都覆盖掉了这个样子，所以为了避免这种方法的话，也是事件的一个功能，对


**委托和接口的联系**

都定义了一系列行为，比如委托使用函数的形式，结构则定义了一些列行为。 别人拿到委托或者结构就知道应该做什么。


**约束** 

每个泛型参数可以有至多一个主要约束，泛型的主要约束是指泛型参数必须是或者继承自某个引用类型，有两个特殊的主要约束：class和struct，分别代表泛型参数是引用类型和值类型。

每个泛型参数可以有无限个次要约束，次要约束和主要约束的语法基本相同，但它规定的是某个泛型参数必须实现所有次要约束指定的接口。

https://blog.csdn.net/foolbirdM/article/details/145455115

> 多重约束 ： 使用 `, or`  这两中来定义接口


**只调用一次的构造函数，创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数来初始化类**

- 在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数来初始化[类](http://msdn.microsoft.com/zh-cn/library/0b0thckt%28v=vs.80%29.aspx)。
- 无法直接调用静态构造函数。
- 在程序中，用户无法控制何时执行静态构造函数。
- 静态构造函数的典型用途是：当类使用日志文件时，将使用这种构造函数向日志文件中写入项。


**多态的实现**

在C#中，多态是面向对象编程的一个重要概念，它允许我们使用同一个方法名来调用不同对象的方法，而具体执行的方法实现是根据对象的类型来确定的。C#实现多态主要有三种方法：**虚方法**、**抽象类**和**接口**。

接口那个硬要实现也是能，但最好就是重载和重写了，不会超出这个范畴了。所以你当时是不想深了，导致时间过得长，他也看出来你紧张了就说你别紧张。


**隐藏方法**

https://www.cnblogs.com/forbetter223/p/10607295.html

---- **New** 关键字

在C#中要重写基类的方法，C#提倡在基类中使用virtual来标记要被重写的方法，在子类也就是派生类中用override关键字来修饰重写的方法。

要是项目中前期考虑不足，我没有在基类(ClassA)中写入Amethod方法，但是派生类(ClassB)中由于需求早早的写完了Amethod方法，并且又有许多类(ClassC,ClassD..)又继承了派生类(ClassB)，并且重写了Amethod方法。当这个时候我又想向最初的基类中(ClassA)添加Amethod方法，这就是存在一个潜在的错误，C#语法会在程序编译的时候提示出警告，需要给派生类(ClassB)重写的方法添加一个关键字“New”,以表示它会隐藏基类中的Amethod方法。

> 一般都是之前写错了，用于弥补的用的


**异步**

他可以就是说挂起，然后就是说不阻塞线程。对，然后就是说让其他方法也能够继续去执行下去。然后等到就是说执行完了之后，然后再去执行， await等待结束了以后，然后再去执行他的逻辑。

实现原理应该是我之前有看到过，但是我可能了解的不多，它应该是一个状态机我记得是。然后就是说它运行到await的时候，它就会启动这个状态机，然后就是说保存当前的进度这个样子，就是说代码的一些内容，包括堆栈这些



**反射**

反射的类型 ：

- 程序集
- 类型
- 函数
- 类
- 属性等

程序集元数据，类型元数据，MSIL代码，资源。

程序集元数据，程序集元数据也叫清单，它记录了程序集的许多重要信息，是程序集进行自我说明的核心文档。当程序运行时，CLR 通过这份清单就能获取运行程序集所必需的全部信息。清单中主要主要包含如下信息：标识信息（包括程序集的名称、版本、文化和公钥等）；文件列表（程序集由哪些文件组成）；引用程序集列表（该程序集所引用的其他程序集）；一组许可请求（运行这个程序集需要的许可）。

类型元数据，类型元数据列举了程序集中包含的类型信息，详细说明了程序集中定义了哪些类，每个类包含哪些属性和方法，每个方法有哪些参数和返回值类型，等等。

MSIL代码，程序集元数据和类型元数据只是一些辅助性的说明信息，它们都是为描述MSIL代码而存在的。MSIL 代码是程序集的真正核心部分，正是它们实现了程序集的功能。比如在“Animals”项目中，五个动物类的C#代码最终都被转换为MSIL 代码，保存在程序集Animals.dll 中，当运行程序时，就是通过这些MSIL 代码绘制动物图像的。

资源，程序集中还可能包含图像、图标、声音等资源。


## 抽象类和接口的区别

抽象类是特殊的类，只是不能被实例化；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。


相似 ：
1. 不能实例化
2. 抱哈您未实现的方法声明
3. 派生类必须实现未实现的方法(抽象类 ： 抽象方法，  接口： 所有)


不同：
1. 接口可以多继承， 抽象类只能单继承
2. 接口可以用于回调
3. 抽象类可以有构造函数， 抽象类成员可以使用任意的访问修饰符
4. 抽象类可以有成员属性，接口不行 
5. 抽象类中允许有实例方法，也就是说**抽象类中除了抽象方法以外，其他的成员允许有具体的实现**