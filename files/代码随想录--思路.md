---
tags:
  - algo
---
## 一些概念

<table>
	<tr>
		<td>类型</td>
		<td>名称</td>
		<td>属性</td>
	</tr>
	<tr>
		<td rowspan="3">数组</td>
		<td>子数组</td>
		<td>连续</td>
	</tr>
	<tr>
		
		<td>子段</td>
		<td>连续</td>
	</tr>
	<tr>
		
		<td>子序列</td>
		<td>**可以不连续，但是相对次序不能乱**</td>
	</tr>
		<tr>
		<td rowspan="2">字符串</td>
		<td>子串</td>
		<td>连续</td>
	</tr>
	<tr>
		
		<td>子序列</td>
		<td>**可以不连续，但是相对次序不能乱**</td>
	</tr>

</table>



## 数组

**二分查找** --- 查找的范围

两种形式 : 左闭右闭 ， 左闭右开

while 的搜索范围 应该是有效的 --- 也就是说再上述一种形式中应该是符合条件的

- 左闭右开 --- 如果 a = b 此时 对于左闭右开来说是非法的。
因此 
- while(a < b)

**双指针遍历数组** --- 双指针

一个进行遍历，一个根据条件进行前进或者后退。(华东窗口同理)

## 树


### 二叉搜索树

性质 ：

- 大小顺序：左子树，根节点，右子树
- 最大最小，最左最右节点
- 中序遍历后的数组有序

#### 使用双指针遍历搜索树

- current  当前指针
- pre 前一个节点 （化为数组后有序的前一个节点）

如何控制 pre


```cpp
node pre = nullptr;

void recrusion(node current)

// 左 ...
// 中 ...
if(pre != null){
	需要用到 pre 的时候
}
pre = current;
// 右 ...
```

## 回溯算法

回溯其实就是递归。 **本质就是纯暴力的算法**

可以解决的问题 : 

- 组合  --- 没有顺序
- 切割
- 子集
- 排列问题 ---- 有顺序的
- 棋盘问题 ---- N皇后

所有问题都可以抽象为一个 N 叉树。 深度就是递归深度

`badcktracking`

在叶子节点收集结果。每个根有多少个子节点 ---- 当前集合中有多少个元素。

### 在搜索的过程中去重

分为两种： 

- 树尾去重
- 树层去重



## 贪心算法

局部最优 推导 全局最优

一些规律: 

- 找不到明显反例，证明局部最优无法推导全局最优 --- 可以使用贪心

