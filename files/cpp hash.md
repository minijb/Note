---
tags:
  - algo
  - cpp
---

**一般哈希表都是用来快速判断一个元素是否出现集合里** 。 比如找到一个学生，在不在队列里，这种查找问题，使用 hash 表，可以快速执行。

**hash 函数** ：用于将需要填充的值或者索引，映射到hash table 的索引上。
**哈希碰撞** : 如果 两个事物的 hash value 相同， 则出现hash 碰撞。一般哈希碰撞有两种解决方法， 拉链法和线性探测法。
**常见hash结构** : 数组，set，map

**c++ 同的 hash 结构** : 

| 集合                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率     | 增删效率     |
| ------------------ | ---- | ---- | -------- | ------ | -------- | -------- |
| std::set           | 红黑树  | 有序   | 否        | 否      | O(log n) | O(log n) |
| std::multiset      | 红黑树  | 有序   | 是        | 否      | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表  | 无序   | 否        | 否      | O(1)     | O(1)     |
set 和 multiset 的key是有序的，不能修改


| 映射                 | 底层实现 | 是否有序  | 数值是否可以重复 | 能否更改数值  | 查询效率     | 增删效率     |
| ------------------ | ---- | ----- | -------- | ------- | -------- | -------- |
| std::map           | 红黑树  | key有序 | key不可重复  | key不可修改 | O(logn)  | O(logn)  |
| std::multimap      | 红黑树  | key有序 | key可重复   | key不可修改 | O(log n) | O(log n) |
| std::unordered_map | 哈希表  | key无序 | key不可重复  | key不可修改 | O(1)     | O(1)     |
map 同理

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

## 三数之和

剪枝操作：

```cpp
num[i] == num[i+1] --> continue //结果集中不能又相同的值
num[i-1] == num[i] --> continue //开头两个字母重复，---> 此状态出现过，无需再次运算
```

i 确定了 ，剩下两个同理

