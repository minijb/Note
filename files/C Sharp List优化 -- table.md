---
tags:
  - Csharp
---
[[C sharp List扩容]]
[[C sharp 重写list]]

## 如果存储复杂类型， 推荐使用 struct 而不是 class。 

**原因** ： 

1. **内存分配**：
    
    - `struct`是值类型，当它被存储在List中时，每个`struct`实例都直接存储在List的内存块中。这意味着每个元素都紧密地存储在一起，减少了内存碎片。
    - `class`是引用类型，List中存储的是对象的引用，而对象本身存储在堆上。这可能导致更多的内存分配和间接引用，增加了内存使用的复杂性。
2. **性能**：
    
    - 由于`struct`存储在连续的内存块中，CPU缓存可以更有效地预取和缓存这些数据，这可能提高访问速度。
    - 对于`class`，由于对象可能分散在堆的不同部分，CPU缓存的效率可能较低。
3. **复制效率**：
    
    - 当List被复制或者元素被移动时，`struct`的复制是简单的位拷贝，这通常更快。
    - `class`的复制涉及到引用的复制，而不是对象数据的复制，但如果需要深拷贝，那么需要复制整个对象，这可能更慢。
4. **内存使用**：
    
    - `struct`通常比`class`实例更小，因为它们不包含额外的引用和一些元数据。
    - `class`实例除了对象数据外，还包含一个指向对象头的引用，这增加了每个实例的内存开销。
5. **垃圾回收**：
    
    - `struct`作为值类型，不会在垃圾回收中被跟踪，这减少了垃圾回收的负担。
    - `class`作为引用类型，它们的生命周期需要被垃圾回收器跟踪，这可能会增加垃圾回收的开销。
6. **不可变性**：
    
    - `struct`通常用于不可变对象，这有助于减少并发编程中的错误和复杂性。
    - `class`可以被修改，这在多线程环境中可能需要额外的同步机制来保证线程安全。
7. **栈分配**：
    
    - 在某些情况下，小的`struct`可能会被栈分配，这可以减少垃圾回收的频率和提高性能。
8. **初始化**：
    
    - `struct`的每个字段都会被初始化为它们的默认值（例如，对于引用类型字段是`null`），而`class`的字段除非被显式初始化，否则不会自动初始化。

然而，使用`struct`也有一些缺点，比如它们不能被继承，而且如果`struct`变得太大，它们的优势可能会减少，因为复制大型`struct`的成本可能会变得非常高。此外，如果`struct`包含很多引用类型的字段，那么它们可能不会比`class`更节省空间。


> 如果开发人员分配了一百万个`PointClass`实例，在“标记和清理”阶段，垃圾收集器将必须扫描一百万个对象并检查每个对象是否还有引用。然后，在“紧凑”阶段，垃圾收集器将不得不移动一百万个对象。最终，存储在`List<PointClass>`实例中的地址应该用新的地址更新。这是很多工作。
>
> 但是对于垃圾收集器，当开发人员分配一百万个`PointStruct`实例时，情况会好得多，因为`List<PointStruct>`垃圾收集器将不得不使用托管堆中的唯一实例。

